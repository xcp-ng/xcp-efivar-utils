#!/usr/bin/env python3

import argparse
import datetime
import json
import logging
import pathlib
import tempfile
import uuid

from xcp_efivar_utils.efi import (
    EFI_CERT_SHA256_GUID,
    EFI_CERT_X509_GUID,
    EFI_VARIABLE_SECUREBOOT_KEYS,
    make_efi_signature_data_sha256,
    make_efi_signature_data_x509,
    make_efi_signature_list,
    make_efi_variable_authentication_2,
)
from xcp_efivar_utils.utils import read_certificate_as_der

import typing

SUPPORTED_ARCHITECTURES = {
    "x86_64": "x64",
}

SVN_OWNER_GUID = uuid.UUID("9d132b6c-59d5-4388-ab1c-185cfcb2eb92")

TIMESTAMP_FORMAT = "%Y-%m-%dT%H:%M:%S%z"


def parse_timestamp(s: str):
    return datetime.datetime.strptime(s, TIMESTAMP_FORMAT)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="""
Implementation of Secure Boot variable generation.
Accepts as input a JSON file following the dbx JSON schema from
https://github.com/microsoft/secureboot_objects or a list of X.509 certificates.
Note that this script could be used to generate PK/KEK/db and not just dbx,
depending on the parameters chosen.
""",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    descriptor_group = parser.add_argument_group("Authenticated variable descriptor info")
    descriptor_group.add_argument("--var-name", default="dbx", help="Authenticated variable name")
    descriptor_group.add_argument(
        "--var-guid", type=uuid.UUID, default="d719b2cb-3d3a-4596-a3bc-dad00e67656f", help="Authenticated variable name"
    )
    descriptor_group.add_argument(
        "--var-attributes",
        type=lambda x: int(x, base=0),
        default=str(EFI_VARIABLE_SECUREBOOT_KEYS),
        help="Authenticated variable attributes",
    )
    descriptor_group.add_argument(
        "--vendor-guid", required=True, type=uuid.UUID, help="Vendor GUID for images and certs"
    )
    descriptor_group.add_argument(
        "--timestamp",
        type=parse_timestamp,
        default=datetime.datetime.now(datetime.timezone.utc),
        help=f"Descriptor timestamp in the format {TIMESTAMP_FORMAT.replace('%', '%%')}",
    )
    descriptor_group.add_argument("--append", action="store_true", help="Appendable descriptor")

    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument("--input", type=argparse.FileType("r"), help="Input JSON file")
    input_group.add_argument("--certs", nargs="+", help="Input certificates")

    json_group = parser.add_argument_group("JSON input mode only")
    json_group.add_argument(
        "--architecture", choices=SUPPORTED_ARCHITECTURES.keys(), help="RPM architecture to build for"
    )
    json_group.add_argument(
        "--sets",
        nargs="*",
        choices=["images", "certificates", "svns"],
        default=["images", "certificates", "svns"],
        help="DBX sets to process",
    )
    json_group.add_argument("--cert-search-path", type=pathlib.Path, help="Root directory of certs specified in JSON")

    signed_group = parser.add_argument_group("Signed updates")
    signed_group.add_argument("--signer-cert", type=pathlib.Path, help="Path of signer certificate")
    signed_group.add_argument("--signer-key", type=pathlib.Path, help="Path of signer private key")

    output_group = parser.add_argument_group("Outputs")
    output_group.add_argument(
        "--output", required=True, type=argparse.FileType("wb"), help="Output authenticated variable"
    )
    output_group.add_argument("--output-signable", type=argparse.FileType("wb"), help="Output signable file")
    output_group.add_argument("--output-content", type=argparse.FileType("wb"), help="Output variable content file")
    output_group.add_argument("--output-signature", type=argparse.FileType("wb"), help="Output signature file")

    args = parser.parse_args()

    logging.getLogger().setLevel(logging.INFO)

    if args.input:
        rpm_arch = args.architecture
        data_arch = SUPPORTED_ARCHITECTURES[rpm_arch]
        sets = set(args.sets)
        with args.input as ifile:
            data = json.load(ifile)
    else:
        data_arch = ""
        sets = {"certificates"}
        data: typing.Any = {"certificates": [{"value": cert} for cert in args.certs]}

    with tempfile.TemporaryDirectory() as tempdir:
        siglists = []

        if "images" in sets:
            siglist_images = []
            images: typing.List[dict] = data["images"][data_arch]
            for image in images:
                if image["hashType"] not in ["SHA256"]:
                    raise RuntimeError(f"Unsupported hash type {image['hashType']}")
                if image.get("authenticodeHash"):
                    hash = bytes.fromhex(image.get("authenticodeHash"))
                    siglist_images.append(make_efi_signature_data_sha256(args.vendor_guid, hash))
            if siglist_images:
                siglists.append(make_efi_signature_list(EFI_CERT_SHA256_GUID, siglist_images))

        if "certificates" in sets:
            certs: typing.List[dict] = data["certificates"]
            cert_path: pathlib.Path = args.cert_search_path or pathlib.Path.cwd()
            for cert in certs:
                cert_bytes = read_certificate_as_der(cert_path / cert["value"], tempdir)
                # each EFI_CERT_X509_GUID stays in its own EFI_SIGNATURE_DATA
                cert_sigdata = make_efi_signature_data_x509(args.vendor_guid, cert_bytes)
                siglists.append(make_efi_signature_list(EFI_CERT_X509_GUID, [cert_sigdata]))

        if "svns" in sets:
            siglist_svns = []
            svns: typing.List[dict] = data.get("svns", [])
            for svn in svns:
                hash = bytes.fromhex(svn.get("value"))
                siglist_svns.append(make_efi_signature_data_sha256(SVN_OWNER_GUID, hash))
            if siglist_svns:
                siglists.append(make_efi_signature_list(EFI_CERT_SHA256_GUID, siglist_svns))

        authvar, content, signable, signature = make_efi_variable_authentication_2(
            varname=args.var_name,
            varguid=args.var_guid,
            siglists=siglists,
            timestamp=args.timestamp,
            attributes=args.var_attributes,
            append=args.append,
            signer_cert=args.signer_cert,
            signer_key=args.signer_key,
            tempdir=tempdir,
        )
        with args.output as ofile:
            ofile.write(authvar)

        if args.output_signable:
            with args.output_signable as sfile:
                sfile.write(signable)

        if args.output_content:
            with args.output_content as cfile:
                cfile.write(content)

        if args.output_signature:
            with args.output_signature as sigfile:
                sigfile.write(signature)
