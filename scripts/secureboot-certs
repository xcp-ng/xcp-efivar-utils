#!/usr/bin/env python3

# SPDX-License-Identifier: GPL-2.0-only

import argparse
import base64
import datetime
import io
import logging
import os
import pathlib
import subprocess
import sys
import tarfile
import tempfile
import uuid
from urllib import request

from xcp_efivar_utils.efi import (
    EFI_CERT_SHA256_GUID,
    EFI_CERT_TYPE_PKCS7_GUID,
    EFI_CERT_X509_GUID,
    EFI_SIGNATURE_LIST,
    EFI_TIME,
    WIN_CERTIFICATE_UEFI_GUID,
)
from xcp_efivar_utils.utils import unserialize_struct
from xcp_efivar_utils.xapi import (
    get_pool_certs,
    get_pool_ref,
    xapi_session,
)

DEFAULT_AUTH_PATHS = {
    "PK": "/usr/share/varstored/PK.auth",
    "KEK": "/usr/share/varstored/KEK.auth",
    "db": "/usr/share/varstored/db.auth",
    "dbx": "/usr/share/varstored/dbx.auth",
}


LATEST_URLS = {
    "dbx": "https://github.com/microsoft/secureboot_objects/raw/refs/heads/main/PostSignedObjects/DBX/amd64/DBXUpdate.bin"
}


def efi_time_to_timestamp(*args):
    return datetime.datetime(
        args[0],
        args[1],
        args[2],
        args[3],
        args[4],
        args[5],
        microsecond=args[7] // 1000,
        tzinfo=datetime.timezone(datetime.timedelta(minutes=args[8])) if args[8] != 2047 else None,
    )


def download(url, tempdir, fname=None, user_agent=None):
    """Download a file.

    url:   the url to the remote file.
    fname: the name to rename the file to upon download.
    tempdir: If True, place file in a temporary directory.
             Otherwise, place in current directory.

    Returns absolute path to downloaded file.
    """
    if fname is None:
        fname = url
    fname = pathlib.Path(tempdir) / os.path.basename(fname)
    d = None
    dest = None
    try:
        print("Downloading %s..." % url)

        req = request.Request(url)
        if user_agent:
            req.add_header("User-Agent", user_agent)

        # These two headers are simply the defaults used by the requests library,
        # which is known to work.  There is no deeper rationale for these exact
        # headers.
        req.add_header("Accept", "*/*")
        req.add_header("Connection", "keep-alive")

        resp = request.urlopen(req)
        data = resp.read()

        with open(fname, "wb") as f:
            f.write(data)

        # Get abspath in temp dir before returning to original directory
        # (only matters if tempdir == True, but also correct if False)
        dest = os.path.abspath(fname)
    except request.HTTPError as e:
        print(
            (
                "error: unable to retrieve certificate from URL: %s. "
                "Error message: %s.\n\nIf the download was blocked with a 403 "
                "HTTP error, you may retry with a different user agent:\n"
                'secureboot-certs install --user-agent="Mozilla/5.0 '
                'My custom user agent"\n\n'
                "If this still doesn't work, you can download and install the "
                "certificates manually:\n"
                "https://xcp-ng.org/docs/guides.html#install-the-default-uefi-certificates-manually"
            )
            % (url, e)
        )
    finally:
        if d:
            os.chdir(d)
    return dest


def is_auth(path):
    """Return True if path is an EFI auth file, otherwise returns False."""
    with open(path, "rb") as f:
        auth = f.read()

    # Validate the timestamp
    auth, year, month, day, hour, minute, seconds, pad1, nanosecond, tz, daylight, pad2 = unserialize_struct(
        EFI_TIME, auth
    )
    try:
        _ = efi_time_to_timestamp(year, month, day, hour, minute, seconds, pad1, nanosecond, tz, daylight, pad2)
    except ValueError:
        return False
    if pad1 != 0 or nanosecond != 0 or tz != 0 or daylight != 0 or pad2 != 0:
        return False

    auth, win_cert_len, win_cert_rev, win_cert_type, efi_cert_type = unserialize_struct(WIN_CERTIFICATE_UEFI_GUID, auth)

    # ESL length is calculated by subtracting win_cert_len, so this is as much as we can do
    if win_cert_len < WIN_CERTIFICATE_UEFI_GUID.size:
        return False
    if len(auth) < (win_cert_len - WIN_CERTIFICATE_UEFI_GUID.size):
        return False

    if win_cert_rev != 0x200:
        return False
    if win_cert_type != 0x0EF1:
        return False
    if uuid.UUID(bytes_le=efi_cert_type) != EFI_CERT_TYPE_PKCS7_GUID:  # noqa: SIM103
        return False

    return True


def create_tarball(paths):
    tarball = io.BytesIO()
    with tarfile.open(mode="w", fileobj=tarball) as tar:
        for name, path in paths.items():
            tar.add(path, arcname="%s.auth" % name)
    return tarball


def getpath(args, name, tempdir):
    val = getattr(args, name)
    if os.path.exists(val):
        logging.debug("using file %s for %s", val, name)
        return val
    elif val == "default":
        logging.debug("%s for %s", val, name)
        return DEFAULT_AUTH_PATHS[name]
    elif val == "latest":
        return download(LATEST_URLS[name], tempdir, f"{name}.auth", user_agent=args.user_agent)
    elif name == "dbx" and val == "none":
        logging.debug("No path for dbx, set dbx to 'none'")
        return None
    else:
        print("error: file %s does not exist" % val)
        sys.exit(1)


def validate_args(args):
    valid_values = {
        "PK": ["default"],
        "KEK": ["default"],
        "db": ["default"],
        "dbx": ["default", "latest", "none"],
    }

    for name in ["PK", "KEK", "db", "dbx"]:
        value = getattr(args, name)
        if value not in valid_values[name] and not os.path.exists(value):
            print("error: file %s does not exist." % value)
            sys.exit(1)


def install(session, args):
    validate_args(args)

    with tempfile.TemporaryDirectory() as tempdir:
        auths = dict()
        for name in ["PK", "KEK", "db", "dbx"]:
            p = getpath(args, tempdir, name)
            if not p:
                continue
            if not is_auth(p):
                print("file %s is not a valid auth file" % p)
                sys.exit(1)
            auths[name] = p

        with create_tarball(auths) as tarball:
            data = base64.b64encode(tarball.getvalue())

        pool_ref = get_pool_ref(session, None)
        if not pool_ref:
            print("Could not retrieve pool from XAPI")
            sys.exit(1)
        session.xenapi.pool.set_custom_uefi_certificates(pool_ref, data)
        print("Successfully installed custom certificates to the XAPI DB for pool.")


def clear(session, _args):
    for pool_ref in session.xenapi.pool.get_all():
        pool_uuid = session.xenapi.pool.get_uuid(pool_ref)
        session.xenapi.pool.set_custom_uefi_certificates(pool_ref, "")
        print("Cleared certificates from XAPI DB for pool %s." % pool_uuid)


def report_esls(buf: bytes):
    while buf:
        print("\t--------------------")

        _, sigtype, esl_size, sigheader_size, siglen = unserialize_struct(EFI_SIGNATURE_LIST, buf)
        siglist = buf[EFI_SIGNATURE_LIST.size + sigheader_size : esl_size]
        buf = buf[esl_size:]

        sigtype = uuid.UUID(bytes_le=sigtype)
        if sigtype == EFI_CERT_SHA256_GUID:
            assert siglen == 48 and len(siglist) % siglen == 0
            print("\t- EFI_SIGNATURE_LIST of type EFI_CERT_SHA256_GUID (%d hashes)" % (esl_size // siglen))
        elif sigtype == EFI_CERT_X509_GUID:
            assert len(siglist) == siglen
            print("\t- EFI_SIGNATURE_LIST of type EFI_CERT_X509_GUID")

            owner = siglist[:16]
            cert = siglist[16:]

            print("\t  Signature owner: %s" % uuid.UUID(bytes_le=owner))
            subprocess.run(
                [
                    "openssl",
                    "x509",
                    "-inform",
                    "DER",
                    "-noout",
                    "-text",
                    "-certopt",
                    "no_header,no_version,no_serial,no_signame,no_pubkey,no_sigdump,no_extensions",
                ],
                input=cert,
            )


def report_auth(auth: bytes):
    _timestamp = unserialize_struct(EFI_TIME, auth)
    auth = _timestamp[0]
    print("\tTimestamp: %s" % efi_time_to_timestamp(*_timestamp[1:]))

    auth, win_cert_len, _win_cert_rev, _win_cert_type, _efi_cert_type = unserialize_struct(
        WIN_CERTIFICATE_UEFI_GUID, auth
    )
    _signature = auth[0 : win_cert_len - WIN_CERTIFICATE_UEFI_GUID.size]
    report_esls(auth[win_cert_len - WIN_CERTIFICATE_UEFI_GUID.size :])
    print("\t--------------------")


def print_cert(path, auth):
    print("\t====================")
    print("\tAuth file: %s" % os.path.basename(path))
    print("\t====================")
    report_auth(auth)
    print()


def report(session, _args):
    try:
        print("\n{} -- Report".format(os.path.basename(sys.argv[0])))
        pool_ref = get_pool_ref(session, None)
        pool_uuid = session.xenapi.pool.get_uuid(pool_ref)
        certs, custom = get_pool_certs(session, pool_ref)
        print("Certificate Info for pool %s:" % pool_uuid)
        print("\tCertificate state: %s\n" % ("Custom" if custom else "Default",))
        print("\tCertificates (%s): %s\n" % (len(certs), ", ".join(certs.keys())))
        for name in ["PK", "KEK", "db", "dbx"]:
            auth = certs.get(name)
            if auth:
                print_cert(name, auth)
    except IOError:
        # This technique taken from: https://docs.python.org/3/library/signal.html#note-on-sigpipe
        # Redirect further stdout flushing (like the broken pipe err message) to /dev/null
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
        sys.exit(1)


def extract(session, args):
    pool_ref = get_pool_ref(session, None)
    certs, _ = get_pool_certs(session, pool_ref)
    cert = certs.get(args.cert)

    if not cert:
        print("error: cert %s does not exist in XAPI pool DB." % args.cert)
        sys.exit(1)

    with open(args.filename, "wb") as f:
        f.write(cert)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Configure guest Secure Boot variables for an XCP-ng system.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--debug",
        "-d",
        action="store_true",
        help="debug output",
    )

    action_parsers = parser.add_subparsers()
    install_parser = action_parsers.add_parser(
        "install",
        help="install custom Secure Boot variables to the pool",
        description="""
Install custom Secure Boot variables to the pool and prevent them from being
automatically updated by XCP-ng.

If no arguments are passed to this command, then the current version of default
PK, KEK, db and dbx variables will be installed.

If a custom auth file is used, it must contain a valid
EFI_VARIABLE_AUTHENTICATION_2 structure. Use the 'gen-sbvar' script to generate
this file.

Notes on dbx selection:

- The 'default' and 'latest' dbx revoke any software that hasn't implemented the
  most recent security fixes, which may include some guest OSes (even if they're
  totally updated, depending how recently the vulnerability was discovered).
  Because it varies per guest OS, check if your guest installer media are
  updated to pass the most recent UEFI revocation before installing the latest
  dbx.

- 'latest' dbx variable contents are downloaded from the Internet, and
  therefore require network access.

- Choosing 'none' allows attackers to simply load vulnerable binaries that
  were previously signed but later revoked, and therefore bypass Secure Boot
  protection.

- Guests may extend, replace, or modify the dbx for the VM in which they run if
  the default KEK is used, even if dbx is set to 'none'.

For older dbx files, see: https://uefi.org/revocationlistfile/archive. They may
be passed to secureboot-certs as custom auth files.
""",
        epilog="""

Certificate / auth file URLs:

- dbx: {}
""".format(LATEST_URLS["dbx"]),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    install_parser.set_defaults(action=install)
    install_parser.add_argument(
        "--user-agent",
        help="custom user agent to download default certificates from the Internet",
        nargs="?",
    )
    install_parser.add_argument(
        "PK",
        metavar="PK",
        help="'default' for the default XCP-ng PK or a path to a custom auth file",
        default="default",
        nargs="?",
    )
    install_parser.add_argument(
        "KEK",
        metavar="KEK",
        help="'default' for the default Microsoft certs or a path to a custom auth file",
        default="default",
        nargs="?",
    )
    install_parser.add_argument(
        "db",
        metavar="db",
        help="'default' for the default Microsoft certs or a path to a custom auth file",
        default="default",
        nargs="?",
    )
    install_parser.add_argument(
        "dbx",
        metavar="dbx",
        help=(
            "'default' for the default Microsoft dbx, 'latest' for the most recent Microsoft dbx, a path to a custom "
            "auth file, or 'none' for no dbx"
        ),
        default="default",
        nargs="?",
    )

    clear_parser = action_parsers.add_parser(
        "clear",
        help="remove all user-installed Secure Boot variables from the pool and revert to the XCP-ng-managed defaults",
        description="Remove all user-installed Secure Boot variables from the pool and revert to the XCP-ng-managed defaults.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    clear_parser.set_defaults(func=clear)

    report_parser = action_parsers.add_parser(
        "report",
        help="view a report containing information about the active Secure Boot variables for the pool",
        description="View a report containing information about the active Secure Boot variables for the pool.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    report_parser.set_defaults(func=report)

    extract_parser = action_parsers.add_parser(
        "extract",
        help="extract a Secure Boot variable from XAPI and save it to disk",
        description="Extract a Secure Boot variable from XAPI and save it to disk.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    extract_parser.set_defaults(action=extract)
    extract_parser.add_argument(
        "cert",
        choices=["PK", "KEK", "db", "dbx"],
        help="the Secure Boot variable name to be extracted from XAPI",
    )
    extract_parser.add_argument(
        "filename",
        help="the output file name",
    )

    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.debug else logging.WARNING)

    func = getattr(args, "func", None)
    if not func:
        parser.print_help()
        sys.exit(1)
    with xapi_session() as session:
        func(session, args)
